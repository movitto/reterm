require 'set'

module RETerm
  # Defines a pair of colors used for foreground / background
  # rendering associated with id and tag list.
  class ColorPair
    attr_accessor :id
    attr_accessor :tags

    # Color Identifiers
    attr_accessor :fg,  :bg

    # Actual NCurses colors
    attr_accessor :fgc, :bgc

    # Return color in CDK format
    def cdk_fmt
      "</#{@id}>"
    end

    def self.builtin
      @builtin ||=  Ncurses.constants.select { |c|
                      c =~ /^COLOR.*/
                    }.collect { |c|
                      c.to_s.gsub("COLOR_", "").downcase.intern
                    }
    end

    def self.default_bkgd
      @dbkgd ||= Ncurses::WINDOW.new(1, 1, 1, 1).getbkgd
    end

    def self.default_bkgd_char
      @dbkgdch ||= default_bkgg & Ncurses::A_CHARTEXT
    end

    def self.default_bkgd_color
      @dbkgdco ||= ((default_bkgd & Ncurses::A_COLOR) >> 8)
    end

    def self.default_fg
      @dfg ||= begin
        f, b = [], []
        Ncurses::pair_content(default_bkgd_color, f, b)
        f.first
      end
    end

    def self.default_bg
      @dbg ||= begin
        f, b = [], []
        Ncurses::pair_content(default_bkgd_color, f, b)
        b.first
      end
    end

    def self.default_color
      @dcp ||= register default_fg, default_bg
    end

    # Reserves and returns block of N colors
    def self.reserve(n=1)
      @reserved   ||= []
      @next_color ||= 50

      0.upto(n) {
        @reserved   << @next_color
        @next_color += 1
      }

      @reserved[-n..-1]
    end

    # Alias for reserve
    def self.next_color
      reserve
    end

    # Redefined system RGB color. Color name should be specified
    # as well as new RGB components
    #
    # @param [String, Symbol] color name of color to change,
    #   ex "red", "blue", etc
    # @param [Integer] r value to assign to red component
    # @param [Integer] g value to assign to green component
    # @param [Integer] b value to assign to blue component
    def self.change(color, r, g, b)
      # XXX shoehorning 256 colors into ncurses 0-1000 scale here,
      # possible explore if alternative solutions are better
      r = r.to_f / 255 * 1000
      g = g.to_f / 255 * 1000
      b = b.to_f / 255 * 1000

      c = builtin.include?(color.to_s.downcase.intern)    ?
          Ncurses.const_get("COLOR_#{color.to_s.upcase}") : color

      Ncurses::init_color c, r, g, b
    end

    # An alias for #change
    def self.define(color, r, g, b)
      change(color, r, g, b)
    end

    # Return RGB components corresponding to system color
    #
    # @param [String, Symbol] color name of color to return
    def self.get(color)
      c = builtin.include?(color.to_s.downcase.intern)    ?
          Ncurses.const_get("COLOR_#{color.to_s.upcase}") : color

      r, g, b = [[],[],[]]
      Ncurses::color_content c, r, g, b

      [r.first, g.first, b.first]
    end

    # Temporarily resassign RGB to named color, invoke callback
    # block, and restore to original
    # @param [Hash<String,Symbol,Array<Integer>>] colors color assignments
    #   to use, mapping of color names to RBG pairs
    # @param [Integer] r value to assign to red component
    # @param [Integer] g value to assign to green component
    # @param [Integer] b value to assign to blue component
    def self.use(colors={})
      orig = {}
      colors.each { |n, rgb|
        orig[n] = get(n)
        change(n, *rgb)
      }

      yield

      colors.each { |n, rgb|
        change(n, *orig[n])
      }

      nil
    end

    # Instantiate a new ColorPair, specifying foreground and background
    # colors as well as any tags.
    #
    # A unique id for this color pair will be autogenerated
    #
    # @param [String, Symbol] fg forground color name
    # @param [String, Symbol] bg background color name
    # @param [Array<String, Symbol>] tags array of tags to assign
    #   to color pair
    def initialize(fg, bg, *tags)
      @@id ||= 0
      @@id  += 1
      @id    = @@id

      @tags = Set.new(tags)

      # FIXME need to verify input is in valid domain
      # before conveRETermng it to symbol w/ "intern"
      fg = fg.to_s.downcase.intern if fg.is_a?(String) || fg.is_a?(Symbol)
      bg = bg.to_s.downcase.intern if bg.is_a?(String) || bg.is_a?(Symbol)
      @fg, @bg = fg, bg

      fgc = fg.is_a?(Symbol) ? Ncurses.const_get("COLOR_#{fg.to_s.upcase}") : fg
      bgc = bg.is_a?(Symbol) ? Ncurses.const_get("COLOR_#{bg.to_s.upcase}") : bg

      @fgc, @bgc = fgc, bgc

      Ncurses.init_pair(@id, fgc, bgc)
    end

    # Returns ncurses color pair corresponding to this instance
    def nc
      Ncurses::COLOR_PAIR(@id)
    end

    # Encapsulates window operation in color pair attribute
    def format(win)
      win.win.attron(nc)
      yield
      win.win.attroff(nc)
    end

    # Create and store a new Color Pair in a static
    # registry
    def self.register(fg, bg, *tags)
      @@registry ||= []
      @@registry  << new(fg, bg, *tags)
      @@registry.last
    end

    # Return all colors pairs
    def self.all
      @@registry ||= []
      @@registry
    end

    # Return Color Pairs found with the given tag
    # or nil for no matches
    def self.for(tag)
      @@registry ||= []
      @@registry.select { |cp| cp.tags.include?(tag) }
    end

    # Return Color Pairs found with the given
    # fg color
    def self.with_fg(color)
      @@registry ||= []
      @@registry.select { |cp|
        color == (color.is_a?(Symbol) ? cp.fg : cp.fgc)
      }
    end

    # Return Color Pairs found with the given
    # bg color
    def self.with_bg(color)
      @@registry ||= []
      @@registry.select { |cp|
        color == (color.is_a?(Symbol) ? cp.bg : cp.bgc)
      }
    end
  end # class ColorPair
end # module RETerm
